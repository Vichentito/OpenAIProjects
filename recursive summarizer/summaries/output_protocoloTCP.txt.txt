El Protocolo de Control de Transmisión (TCP) es un protocolo de nivel de transporte que proporciona comunicación entre procesos usando números de puerto. Está orientado a conexión y ofrece fiabilidad, además de añadir a IP las características de orientación a conexión y fiabilidad. Los servicios ofrecidos por TCP a los procesos en el nivel de aplicación son: comunicación proceso a proceso, devolución del datagrama recibido al emisor, descartar cualquier datagrama recibido, usuarios activos, devolver la fecha y hora, devolver una cita del día, devolver una tira de caracteres, File Transfer Protocol (conexión de datos y control), Terminal en Red, Simple Mail Transfer Protocol, DNS Domain Name Server y Protocolo Bootstra Hypertext Transfer Protocol. TCP, a diferencia de UDP, es un protocolo orientado a flujo. Esto significa que los procesos emisor y receptor pueden intercambiar datos como un flujo de bytes. Por lo tanto, para almacenar los datos que viajan entre estos dos procesos se necesitan buffers. Además, TCP usa mecanismos de control de flujo y error a nivel de transporte. Esto significa que se establece un entorno en el cual ambos procesos parecen estar conectados por un tubo imaginario que transporta sus datos a través de Internet. Una vez que se establece la conexión, se puede efectuar transmisión de datos bidireccional. Para garantizar la seguridad, existen estrategias como el retrasar la asignación de recursos hasta que toda la conexión esté completa (usando lo que se denomina una cookie).

Los segmentos de datos enviados por el cliente tienen el flag PSH (push) activo para que el servidor TCP sepa que debe entregar los datos al proceso servidor tan pronto como Ileguen. Esta operación se llama entrega inmediata de datos (pushing). El TCP emisor usa un almacén para guardar el flujo de datos que vienen desde el programa de aplicación emisor. Por ejemplo, un programa de aplicación puede querer enviar una pulsación de teclado a la aplicación en el extremo contrario y recibir una respuesta inmediata, lo cual no es posible con la transmisión y la entrega diferida, por lo que requiere esta operación de entrega inmediata (push). Para esto, el TCP emisor no debe esperar a rellenar su ventana, sino crear un segmento y enviarlo inmediatamente activando el bit push (PSH). La mayoría de las implementaciones actuales de TCP ignoran estas peticiones, pero puede elegir usar o no esta característica. Además, hay veces en las que un programa de aplicación necesita enviar bytes de datos urgentes, por lo que usan el bit URG activado para indicar que los datos son urgentes. Finalmente, cualquiera de las dos partes involucradas en un intercambio de datos (cliente 0 servidor) puede cerrar la conexión normalmente siendo el cliente. Esto se logra con la negociación en tres pasos, donde el cliente envía un primer segmento para avisar al servidor que quiere cerrar la conexión, luego recibe un segundo segmento del servidor confirmando que la conexión ha sido cerrada y finalmente envía un tercer segmento confirmando que ha recibido este segundo segmento.

Un segmento FIN con el flag FIN activo es un segmento de control que consume solo un número de secuencia. El servidor TCP, después de recibir el segmento FIN, informa a su proceso de la situación y envía el segundo segmento, un segmento FIN + ACK, para confirmar la recepción del segmento FIN desde el cliente y anunciar el cierre de la conexión en la dirección contraria. El cliente TCP envia el último segmento, un segmento ACK, para confirmar la recepción del segmento FIN desde el servidor y este no puede llevar datos ni consume numero de secuencia. En TCP, un semicierre permite que un extremo deje de enviar datos mientras sigue recibiendo. Normalmente inicia el cliente y puede ocurrir cuando el servidor necesita todos los datos antes de procesarlos. El cliente envía un segmento FIN para cerrar la conexión en la dirección de salida, pero la dirección de entrada se mantiene abierta hasta que reciba los datos ordenados. El servidor acepta el semicierre enviando un segmento ACK y sigue enviando datos hasta que envía un segmento FIN confirmado por el cliente con un ACK. Para gestionar el control de flujo, TCP acusa una ventana deslizante que es orientada a byte y es de tamaño variable. La ventana se extiende a una parte del almacén que contiene los bytes recibidos del proceso; los bytes dentro de la ventana son los bytes que pueden estar en tránsito; se pueden enviar sin preocuparse de la confirmación. La ventana imaginaria tiene dos paredes: una izquierda y una derecha. Cuando la conexión finalmente cierra, el número de secuencia del último segmento ACK sigue siendo x porque no se consume ningún número de secuencia durante la transferencia de datos en esa dirección.

Las actividades de abrir, cerrar y reducir una ventana están bajo el control del receptor (y dependen de la congestión de la red) y no del emisor. Abrir una ventana significa mover la pared derecha a la derecha, lo que permite tener nuevos bytes listos para enviar en el almacén. Cerrar la ventana significa mover la pared izquierda a la derecha, lo que significa que algunos bytes han sido confirmados y el emisor no tiene que preocuparse de ellos nunca más. Reducir la ventana significa mover la pared derecha hacia la izquierda, lo que se desaconseja fuertemente ya que revocaría la elegibilidad de algunos bytes para ser enviados. El tamaño de la ventana en un lado es determinado por el menor de estos dos valores: ventana de recepción (rwnd) o ventana de congestión (cwnd). Por ejemplo, si el receptor tiene un tamaño de almacén de 5000 bytes y 1000 bytes de datos recibidos y no procesados, entonces el valor de rwnd es 4000 bytes. Además, se usan almacenes para los mecanismos de control de flujo y error usados por TCP. La Figura 23.12 muestra movimientos de datos en una dirección. El área gris oscuro mantiene bytes que han sido enviados pero no están todavía confirmados, mientras que el área gris clara contiene los bytes a ser enviados por el TCP emisor. Por último, TCP agrupa un número de bytes en un paquete denominado segmento. Esto se encapsula en datagramas IP y se transmite. TCP es un protocolo orientado a conexión, lo que significa que hay un periodo inicial durante el cual los dos extremos intercambian información sobre los parámetros necesarios para establecer una conexión confiable antes de que se inicie el flujo real de datos.

Un proceso A quiere enviar y recibir datos de otro proceso en el sitio B, lo que se muestra a continuación sucede: Primero, ambos TCP establecen una conexión entre ellos. Después, intercambian datos en ambas direcciones. Finalmente, se cierra la conexión. Esta conexión es virtual, no física. El segmento TCP es encapsulado en un datagrama IP y se puede enviar fuera de orden, perderse o corromperse, en cuyo caso es reenviado. Cada segmento puede usar una ruta distinta hasta el destino. TCP proporciona un servicio fiable ya que usa un mecanismo de confirmación para comprobar que los datos han llegado completamente y seguros. Esto se consigue a través de varias características. Por ejemplo, el sistema de numeración donde no hay un campo para el número de segmento en la cabecera de segmento; en su lugar hay dos campos denominados número de secuencia y número de confirmación. Estos dos campos se refieren al número de byte y no al número de segmento. Además, TCP numera todos los bytes de datos que se transmiten en una conexión y usa esta numeración para el control de flujo y error. Por ejemplo, si una conexión TCP transfiere un fichero de 5000 bytes, el primer byte tendrá el número 10.001; entonces los números de secuencia para cada segmento serían desde 10.001 hasta 15.000 si los datos se envían en cinco segmentos, cada uno con 1000 bytes. Por último, para proporcionar los servicios mencionados anteriormente, TCP tiene control de flujo (donde el receptor controla la cantidad de datos que deben ser enviados por el emisor), control de error (donde se considera el segmento como la unidad de datos para la detección del error) y control de congestión (donde la cantidad de datos enviados por el emisor no sólo es controlado por el receptor sino también por el nivel de congestión).

La cabecera de un segmento TCP es una estructura de entre 20 y 60 bytes, seguida por los datos del programa de aplicación. Esta cabecera contiene varios campos, como la dirección puerto origen (16 bits) y destino (16 bits), el número de secuencia (32 bits) y confirmación (32 bits), la longitud de cabecera (4 bits), los 6 bits de control, el tamaño de ventana (16 bits) y suma de comprobación (16 bits). Estos campos permiten el control de flujo, establecer y terminar la conexión, abortar la conexión y recibir el modo de transferencia de datos en TCP. Por otro lado, una conexión TCP es orientada a conexión. Esto significa que establece un camino virtual entre el origen y el destino. Todos los segmentos que pertenecen a un mensaje se envían por este camino virtual. Por ejemplo, si un usuario quiere enviar un correo electrónico a otro usuario, todos los datos del correo se enviarán por este camino virtual.

El Camino Virtual para Todo el Mensaje (Virtual Path for All Message) facilita el proceso de confirmación de tramas así como la retransmisión de tramas dañadas o perdidas. La conexión en TCP es virtual, no física, ya que opera a un alto nivel y usa los servicios de IP para enviar los segmentos individuales al receptor; sin embargo, controla la conexión por sí mismo. Si un segmento se pierde o corrompe, TCP lo retransmite. A diferencia de TCP, IP no es consciente de la retransmisión. Por ejemplo, si un segmento llega fuera de orden, TCP lo mantiene hasta que llegan los segmentos perdidos; sin embargo, IP no es consciente del reordenamiento. El establecimiento de una conexión en TCP se denomina negociación en tres pasos (three-way handshaking). En este ejemplo, un programa de aplicación (cliente) quiere establecer una conexión con otro programa de aplicación (servidor) usando TCP como protocolo de nivel de transporte. Primero, el servidor le dice a su TCP que está listo para aceptar una conexión (apertura pasiva). A continuación, el cliente emite una petición para una apertura activa. Esto le permite a TCP empezar la negociación en tres pasos: El cliente envía el primer segmento SYN; El servidor envía el segundo segmento SYN+ACK; y El cliente envía el tercer segmento ACK. También puede ocurrir una situación rara denominada apertura simultánea, cuando ambos procesos emiten una apertura activa; en este caso sólo se establece una única conexión entre ellos. Finalmente, hay que mencionar el ataque por SYN másivo (SYN flooging attack), que consiste en bombardear al servidor para saturarlo y evitar que otros usuarios se conecten a él.

Es aceptable sufrir un ataque de seguridad peligroso denominado ataque por SYN masivo. Esto ocurre cuando un atacante malicioso envía un número muy grande de SYN a un servidor, fingiendo que cada uno de ellos viene de un cliente distinto mediante el enmascaramiento de la dirección IP de los datagramas. El servidor, asumiendo que los clientes están enviando una apertura activa, asigna recursos ocupados y sin utilizar. Si durante este corto espacio de tiempo el número de segmentos SYN es muy grande, el servidor se queda sin recursos y puede fallar. Este ataque por SYN masivo pertenece a un tipo de ataque de seguridad denominado ataque por denegación de servicio, en el cual un atacante monopoliza un sistema con tantas peticiones de servicio que el sistema se colapsa y niega servicio a cualquier petición. Por ejemplo, si un atacante envía miles o millones de peticiones al servidor, este último será incapaz de manejar estas peticiones y por ende se verá obligado a rechazarlas todas. Algunas implementaciones de TCP tienen estrategias para aliviar los efectos de un ataque por SYN. Algunas han impuesto un límite en las peticiones de conexión durante un determinado periodo de tiempo. Otras implementaciones han diseñado mecanismos que permiten al servidor detectar y rechazar peticiones que no cumplan con los requisitos necesarios para establecer la conexión. Estas herramientas son muy útiles para prevenir los efectos negativos que pueden causar los ataques por SYN masivos.